# Search Patterns & Best Practices Guide

**Status:** Active | **Authority:** Human-Locked

## Overview

This guide explains how to leverage the new semantic search and temporal folding capabilities of the ECE Core system to achieve optimal context retrieval results.

## 1. Semantic Intent Translation (Standard 042)

The system now uses a local SLM (GLM-1.5B) to translate natural language queries into optimized database queries before hitting the database.

### How It Works
- Natural language queries are intercepted by the API
- The local model translates the query into optimized keywords
- The model infers relevant buckets based on context

## 2. Schema Fields Update

The database schema has been updated to support enhanced categorization and tagging:

### Multi-Bucket Support
- **Field:** `buckets: [String]` (was `bucket: String`)
- **Purpose:** Allows memories to belong to multiple categories simultaneously
- **Example:** A memory can belong to both `['work', 'project-x', 'meeting']` buckets
- **Usage:** When searching with bucket filters, memories with any matching bucket will be returned

### Tags Field
- **Field:** `tags: String` (JSON-formatted array)
- **Purpose:** Stores semantic tags generated by the inference engine
- **Format:** JSON string representing an array of tags (e.g., `'["important", "follow-up", "technical"]'`)
- **Usage:** Used for associative context windowing and semantic search enhancement
- The strategy (broad/precise) influences search depth

### Epochs Field
- **Field:** `epochs: String` (JSON-formatted array)
- **Purpose:** Stores epochal classifications for hierarchical organization (Epochs -> Episodes -> Propositions)
- **Format:** JSON string representing an array of epoch names (e.g., `'["Project Alpha Development", "Q3 2025 Planning"]'`)
- **Usage:** Used for epochal navigation and organizing memories into high-level thematic clusters
- Enables the Epochal Historian to group related memories across time periods

### Example
**Input Query:** "I need to study python concepts and gotchas to prepare for my interview tomorrow"
**Translated Query:** "python programming nuances common errors interview prep"
**Inferred Buckets:** ['dev', 'core']

## 3. Temporal Folding (Standard 047)

The system maintains immutable history but folds it during retrieval to save tokens.

### How It Works
- Each file save creates a new node linked by `source`
- During retrieval, if multiple memories share the same `source`:
  - **The Head (Latest):** Is fully rendered with the "Elastic Window" method
  - **The Tail (History):** Is compressed into a metadata block (Timestamps + IDs only)
- Never outputs full text for superseded versions unless explicitly requested with `deep: true`

### Example Output
```
### Source: context/python_notes.md (Score: 95)
**History:**
- 2025-09-01 10:00 (v1)
- 2025-08-30 14:00 (v0)

... [Latest Content Snippets] ...
```

## 4. Elastic Window Search (Standard 046)

When assembling context, the system allocates:
- **70% of character budget** to Direct Matches (Keyword/Vector)
- **30% of character budget** to Associative Matches (Shared Tags)

### How It Works
1. **Direct Search:** Finds most relevant documents using CozoDB FTS
2. **Tag Harvesting:** Extracts buckets from direct results
3. **Associative Search:** Finds related content based on shared tags

## 5. Epochal Historian (Recursive Decomposition)

The Dreamer service now includes an Epochal Historian that performs recursive decomposition of memories into three hierarchical levels:

### Epochs
- Major time periods or thematic clusters of memories
- Represent large-scale patterns and trends over time
- Examples: "Project Alpha Development", "Q3 2025 Planning", "Team Restructuring"

### Episodes
- Specific events or topics within an Epoch
- More granular than Epochs but broader than individual facts
- Examples: "Initial Project Alpha Meeting", "Budget Approval Process", "Team Onboarding Session"

### Propositions
- Individual facts, statements, or insights
- Atomic units of knowledge that can be referenced independently
- Examples: "Budget approved for $50K", "New team member starts Monday", "API endpoint changed to /v2"

### Search Integration
- Memories tagged with Epochal classifications can be searched using epochal tags
- Use syntax like `#epoch:"Project Alpha Development"` to search within specific epochs
- The system automatically suggests relevant epochs during search if available

## 6. Memory Tagging System

The system automatically assigns buckets based on:
- **File Location:** Top-level folder name becomes a bucket
- **Content Analysis:** Dreamer service adds semantic tags
- **Epochal Classification:** Dreamer service assigns memories to Epochs, Episodes, and Propositions
- **User Input:** Explicit buckets during ingestion

### Default Buckets
- `core`: General content that doesn't fit elsewhere
- `pending`: Files in root context directory awaiting categorization
- Custom buckets based on folder structure: `dev`, `research`, `personal`, etc.

## 7. Optimized Search Strategies

### For Broad Discovery
- Use natural language queries
- Allow semantic translation to infer relevant keywords
- Accept default broad strategy
- Results will include associative matches

### For Precise Retrieval
- Use specific technical terms
- Set `strategy: "precise"` in query parameters
- Results will focus on exact matches
- Consider using `deep: true` for historical versions

### For Historical Context
- Set `deep: true` in query parameters
- Access all versions of a document
- View evolution of ideas over time
- Compare different iterations

### For Epochal Navigation
- Use epochal tags to navigate large-scale patterns
- Combine epochal tags with temporal tags for precise historical searches
- Example: `#epoch:"Project Alpha Development" @Q3 @2025`

## 8. Token Economy Best Practices

### Efficient Queries
- Use specific terminology for precise results
- Leverage semantic translation for conceptual searches
- Combine natural language with explicit filters
- Use bucket filters to narrow scope when needed

### Managing Context Length
- The system automatically manages character budgets
- Latest versions get priority in display
- Historical versions are available on demand
- Associative matches enhance discovery without overwhelming

## 9. Practical Examples

### Example 1: Research Topic
**Query:** "Find all information about transformer architectures"
**System Behavior:**
- Semantic translation expands to "transformer neural networks attention mechanism"
- Direct search finds core papers and articles
- Associative search finds related concepts
- Temporal folding shows latest versions of key documents

### Example 2: Project Context
**Query:** "Show me the current state of the API design"
**System Behavior:**
- Semantic translation focuses on "API design documentation"
- Temporal folding shows latest version of API docs
- History section indicates previous iterations
- Associative search finds related implementation details

### Example 3: Historical Analysis
**Query:** "How did our approach to authentication evolve?" (with `deep: true`)
**System Behavior:**
- Finds all versions of authentication-related documents
- Shows chronological evolution
- Highlights changes and improvements over time
- Links related concepts across versions

### Example 4: Epochal Search
**Query:** "#epoch:'Project Alpha Development' authentication changes"
**System Behavior:**
- Filters memories to those classified under "Project Alpha Development" epoch
- Searches for authentication-related content within that epoch
- Returns relevant episodes and propositions from the specified time period
- Shows evolution of authentication approaches during the project

## 10. Troubleshooting Common Issues

### Issue: Too Much Context
**Solution:** Use more specific queries or add bucket filters

### Issue: Missing Relevant Results
**Solution:** Try broader natural language queries to leverage semantic translation

### Issue: Outdated Information
**Solution:** Check temporal folding to see if newer versions exist

### Issue: Performance Problems
**Solution:** Reduce max_chars parameter or use more specific queries

### Issue: Natural Language Queries Returning No Results
**Root Cause:** This indicates a failure in Semantic Intent Translation (Standard 042). The system is not properly converting natural language into searchable keywords.
**Diagnosis:** Check if `inference.translateIntent()` is properly converting the query into optimized keywords and inferred buckets.
**Solution:**
1. Verify the semantic translation function is being called
2. Ensure the local model is returning valid JSON with keywords
3. Implement fallback keyword extraction if semantic translation fails
4. Refer to Standard 048 for proper retrieval layer optimization

### Issue: Low SLM Comprehension Scores
**Diagnosis:** According to Standard 048, first diagnose the retrieval layer before assuming inference issues. Check if the system is retrieving relevant data before concluding the model cannot understand it.
**Solution:**
1. Verify that relevant content is being retrieved
2. Check if the issue is in retrieval (no data) vs inference (cannot understand data)
3. Optimize retrieval algorithms before upgrading inference models

## 11. Integration Tips

### For Developers
- Use the `/v1/memory/search` endpoint with natural language queries
- Leverage bucket filters for targeted searches
- Consider using `deep: true` for historical analysis
- Monitor the `meta` field in responses for translation insights
- Access epochal classifications through the Dreamer service

### For Users
- Think in terms of concepts rather than exact keywords
- Trust the semantic translation to find relevant content
- Use the history view to understand document evolution
- Explore epochal organization to understand large-scale patterns
- Combine searches with different strategies for comprehensive results

---
*End of Guide*